package externalapi

import (
	"reflect"
	"testing"
)

type TransactionToCompare struct {
	tx             *DomainTransaction
	expectedResult bool
}

type TestDomainTransactionStruct struct {
	baseTx                 *DomainTransaction
	transactionToCompareTo []*TransactionToCompare
}

func InitTestBaseTransaction() *DomainTransaction {

	testTx := &DomainTransaction{
		Version:      1,
		Inputs:       nil,
		Outputs:      []*DomainTransactionOutput{},
		LockTime:     1,
		SubnetworkID: DomainSubnetworkID{0x01},
		Gas:          1,
		PayloadHash: DomainHash{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		Payload: []byte{0x01},
		Fee:     0,
		Mass:    1,
		ID: &DomainTransactionID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
	}
	return testTx
}

func InitTestTransactionToCompare() []*TransactionToCompare {

	testTx := []*TransactionToCompare{{
		tx: &DomainTransaction{
			Version:      1,
			Inputs:       []*DomainTransactionInput{},
			Outputs:      nil,
			LockTime:     1,
			SubnetworkID: DomainSubnetworkID{0x01},
			Gas:          1,
			PayloadHash: DomainHash{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			Payload: []byte{0x01},
			Fee:     0,
			Mass:    1,
			ID: &DomainTransactionID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
		},
		expectedResult: false,
	}, {
		tx: &DomainTransaction{
			Version:      1,
			Inputs:       nil,
			Outputs:      []*DomainTransactionOutput{},
			LockTime:     1,
			SubnetworkID: DomainSubnetworkID{0x01},
			Gas:          1,
			PayloadHash: DomainHash{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			Payload: []byte{0x01},
			Fee:     0,
			Mass:    1,
			ID: &DomainTransactionID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
		},
		expectedResult: true,
	},
	}

	return testTx

}

func InitTestDomainTransactionForClone() []*DomainTransaction {

	tests := []*DomainTransaction{
		{
			Version:      1,
			Inputs:       nil,
			Outputs:      []*DomainTransactionOutput{},
			LockTime:     1,
			SubnetworkID: DomainSubnetworkID{0x01},
			Gas:          1,
			PayloadHash: DomainHash{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			Payload: []byte{0x01},
			Fee:     0,
			Mass:    1,
			ID: &DomainTransactionID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
		}, {
			Version:      1,
			Inputs:       []*DomainTransactionInput{},
			Outputs:      nil,
			LockTime:     1,
			SubnetworkID: DomainSubnetworkID{0x01},
			Gas:          1,
			PayloadHash: DomainHash{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			Payload: []byte{0x01},
			Fee:     0,
			Mass:    1,
			ID: &DomainTransactionID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
		},
	}
	return tests
}

func initTestDomainTransactionForEqual() []TestDomainTransactionStruct {

	tests := []TestDomainTransactionStruct{
		{
			baseTx:                 InitTestBaseTransaction(),
			transactionToCompareTo: InitTestTransactionToCompare(),
		},
	}
	return tests
}

func TestDomainTransaction_Equal(t *testing.T) {

	txTests := initTestDomainTransactionForEqual()
	for i, test := range txTests {
		for j, subTest := range test.transactionToCompareTo {
			result1 := test.baseTx.Equal(subTest.tx)
			if result1 != subTest.expectedResult {
				t.Fatalf("Test #%d:%d: Expected %t but got %t", i, j, subTest.expectedResult, result1)
			}
			result2 := subTest.tx.Equal(test.baseTx)
			if result2 != subTest.expectedResult {
				t.Fatalf("Test #%d:%d: Expected %t but got %t", i, j, subTest.expectedResult, result2)
			}
		}
	}
}

func TestDomainTransaction_Clone(t *testing.T) {

	txs := InitTestDomainTransactionForClone()
	for i, tx := range txs {
		txClone := tx.Clone()
		if !txClone.Equal(tx) {
			t.Fatalf("Test #%d:[Equal] clone should be equal to the original", i)
		}
		if !reflect.DeepEqual(tx, txClone) {
			t.Fatalf("Test #%d:[DeepEqual] clone should be equal to the original", i)
		}
	}
}
